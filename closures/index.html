<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HQ-Closures</title>
</head>

<body>


    <script>
        // Normal vs Arrow Functions differences
        // 1.
        // Syntax:(Normal Function)
        function normalFunction(param) {
            return param + 10;
        }
        // Arrow Function:
        const arrowFunction = (param) => param + 10;
        // 2.
        // this binding
        // In normal functions, the value of this is dynamically determined based on how the function is called.
        // const obj = {
        //     value: 5,
        //     normalFunction: function () {
        //         console.log(this); //current scope of the obj
        //         let that = this
        //         function anotherfunc() {
        //             console.log(this); //undefined cz now this scope is limited to this new func (ab this apna new scope bna lega e.g window)
        //             console.log(that.value);//it will show values
        //         }
        //         anotherfunc()
        //         return this
        //     }
        // };
        // console.log(obj.normalFunction()); // Output: 5
        // Arrow functions capture the value of this from the surrounding context, and the value of this remains the same throughout the function's execution.
        let xx = 12
        const obj = {
            value: 5,
            show: () => {
                console.log(this);//window scope
            },
            arrowFunction: function () {
                return () => {
                    console.log(this);// ye apny parent ka scope(lexical scope) show kre ga means value:5 yha accessable hai
                }
            },

        };

        console.log(obj.show()); // Output: undefined (In this case, this refers to the global object, where value is not defined.)
        // let b = 34
        // function name(params) {
        //     let x = 12
        //     console.log(this);
        //     let obj={
        //         c:34,
        //         val:function(){
        //             console.log(this);
        //         }
        //     }
        //     return obj
        // }
        // let a=name()
        // console.log(a.val());









        // Lexical scope
        // 1. how variable names are resolved during the runtime of a program is called lexical scope.

        // global scope
        let x = 12;
        const parentFunc = () => {
            // local scope
            let y = 2;
            console.log(x);
            console.log(y);
        }
        console.log(y);
    </script>
</body>

</html>